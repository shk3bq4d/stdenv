# /* ex: set filetype=sh: */

      +rGNU  +rFreeBSD   -rGNU  -rFreeBSD
\s    x      x           o      x



sed -n -e '/TERMINATE/,$p' # will print the line matching TERMINATE till the end of the file: Explained: -n disables default behavior of sed of printing each line after executing its script on it, -e indicated a script to sed, /TERMINATE/,$ is an address (line) range selection meaning the first line matching the TERMINATE regular expression (like grep) to the end of the file ($), and p is the print command which prints the current line.



sed -e '1,/TERMINATE/d' #will print from the following line matching TERMINATE till the end of the file: Explained: 1,/TERMINATE/ is an address (line) range selection meaning the first line for the input to the 1st line matching the TERMINATE regular expression, and d is the delete command which delete the current line and skip to the next line. As sed default behavior is to print the lines, it will print the lines after TERMINATE to the end of input.
sed -e '5,10d;12d' file # delete line 5 to 10 as well as line 12
sed -i -e 551d ~/.ssh/known_hosts # delete line 551 of known hosts

sed -r -n -e '/./,$p'                 # delete leading empty lines
sed -r -n -e '/\S/,$p'                # delete leading blank lines
sed -e :a -e '/^\n*$/{$d;N;ba' -e '}' # delete all trailing blank lines at end of file EOF

sed -e "s/\b\(.\)/\u\1/g" # GUN: capitalize/uppercase first letter of each word


sed -e '/TERMINATE/,$d' # the lines before TERMINATE:


sed -e '1,/TERMINATE/w before
/TERMINATE/,$w after' file # if you want both lines before and after TERMINATE in 2 different files in a single pass:

The before and after files will contain the line with terminate, so to process each you need to use:

head -n -1 before
tail -n +2 after

Edit2:

IF you do not want to hard-code the filenames in the sed script, you can:

before=before.txt
after=after.txt
sed -e "1,/TERMINATE/w $before
/TERMINATE/,\$w $after" file

But then you have to escape the $ meaning the last line so the shell will not try to expand the $w variable (note that we now use double quotes around the script instead of single quotes).

I forgot to tell that the new line is important after the filenames in the script so that sed knows that the filenames end.


sed -e '/^\s*$/ d' # remove emptylines

rint between line 45 and 50
sed -n '45,50p' filename

http://www.gnu.org/software/sed/manual/html_node/Command-and-Option-Index.html#Command-and-Option-Index


#apply commands only on the first match
sed -r -e '0,/OTHRPRTY/{s/OTHRPRTY/youpiiiiiiiiiiiiiiiiiiii/}' $i

sed -n '/USERNAME/,/-----$/ p' #print between two regexp


sed -e 's/\(.*\)/\L\1/' input.txt > output.txt # uppercase
sed -e 's/\(.*\)/\1/' input.txt > output.txt # group backtrace



#skip first and last line
sed '1d; $d'


pattern   normal -r
\s        works  works
\d        NOK    NOK
[0-9]     works  works
+         NOK    works



sed -r \
    -e '/^    bgcolor/ d' \
    -e '/Generated by SchemaSpy/ d' \
    -e '/OH(...CRE|...MOD|STATUT|OPTLCK)/ d' \
    -e '/DONNEESPROF.*PARTENAIRE/{s/arrowhead=none/arrowhead=crowodot/;s/arrowtail=crowodot/arrowtail=none/;s/dir=back//;s/(\S+) -> (\S+)/\2->\1/}' \
    -e '/OCRTELEPHONE.*PARTENAIRE/{s/arrowhead=none/arrowhead=crowodot/;s/arrowtail=crowodot/arrowtail=none/;s/dir=back//;s/(\S+) -> (\S+)/\2->\1/}' \
    -e '/OCRRELATION.*PARTENAIRE/{s/arrowhead=none/arrowhead=crowodot/;s/arrowtail=crowodot/arrowtail=none/;s/dir=back//;s/(\S+) -> (\S+)/\2->\1/}' \
    -e '/OCRDOCUMENTS.*PARTENAIRE/{s/arrowhead=none/arrowhead=crowodot/;s/arrowtail=crowodot/arrowtail=none/;s/dir=back//;s/(\S+) -> (\S+)/\2->\1/}' \
    -e 's/:[we]//g' \
    diagrams/summary/relationships.real.large.dot > /d/viz/scanocr.large.viz


# switch two lines
sed -e '
/^Paco/ {
:notdone
  N
  s/^\(Paco[^\n]*\)\(\n\([^\n]*\n\)*\)\(Vinh[^\n]*\)$/\4\2\1/
  t
  bnotdone
}
After matching /^Paco/ we read into the pattern buffer until s// succeeds (or EOF: the pattern buffer will be printed unchanged). Then we start over searching for /^Paco/.


sed -r -e "s/(\\w+\\s+)(\\w+\\s+)(\\w+\\s+)(.*)/$(echo -ne "$RED")\\1$(echo -ne "$BLUE")\\2$(echo -ne "$GREEN")\\3$(echo -ne "$OFF")\\4/"  # colorization

sed -r -e s/[\d001-\d020]//g' # removes non-printables
tr -dc '[[:print:]]'          # removes non-printables

# sed character classes
‘[:alnum:]’ Alphanumeric characters: ‘[:alpha:]’ and ‘[:digit:]’; in the ‘C’ locale and ASCII character encoding, this is the same as ‘[0-9A-Za-z]’.

‘[:alpha:]’ Alphabetic characters: ‘[:lower:]’ and ‘[:upper:]’; in the ‘C’ locale and ASCII character encoding, this is the same as ‘[A-Za-z]’.

‘[:blank:]’ Blank characters: space and tab.

‘[:cntrl:]’ Control characters. In ASCII, these characters have octal codes 000 through 037, and 177 (DEL). In other character sets, these are the equivalent characters, if any.

‘[:digit:]’ Digits: 0 1 2 3 4 5 6 7 8 9.

‘[:graph:]’ Graphical characters: ‘[:alnum:]’ and ‘[:punct:]’.

‘[:lower:]’ Lower-case letters; in the ‘C’ locale and ASCII character encoding, this is a b c d e f g h i j k l m n o p q r s t u v w x y z.

‘[:print:]’ Printable characters: ‘[:alnum:]’, ‘[:punct:]’, and space.

‘[:punct:]’ Punctuation characters; in the ‘C’ locale and ASCII character encoding, this is ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~.

‘[:space:]’ Space characters: in the ‘C’ locale, this is tab, newline, vertical tab, form feed, carriage return, and space.

‘[:upper:]’ Upper-case letters: in the ‘C’ locale and ASCII character encoding, this is A B C D E F G H I J K L M N O P Q R S T U V W X Y Z.

‘[:xdigit:]’ Hexadecimal digits: 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f.
